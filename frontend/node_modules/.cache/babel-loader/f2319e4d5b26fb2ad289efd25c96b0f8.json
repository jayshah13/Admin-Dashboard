{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\n * Marker module used to render the marker for line type series.\n */\n\nvar Marker =\n/** @class */\nfunction (_super) {\n  __extends(Marker, _super);\n  /**\n   * Constructor for the marker module.\n   *\n   * @private\n   */\n\n\n  function Marker(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * Render the marker for series.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Marker.prototype.render = function (series) {\n    var _this = this;\n\n    var redraw = series.chart.redraw;\n    this.createElement(series, redraw);\n\n    var _loop_1 = function (point) {\n      if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n        point.symbolLocations.map(function (location, index) {\n          if (series.marker.shape !== 'None') {\n            _this.renderMarker(series, point, location, index, redraw);\n          }\n        });\n      }\n    };\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      _loop_1(point);\n    }\n  };\n\n  Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n    var seriesIndex = series.index === undefined ? series.category : series.index;\n    var marker = series.marker;\n    var border = {\n      color: marker.border.color,\n      width: marker.border.width\n    };\n    var borderColor = marker.border.color;\n    var previousLocation;\n    var previousPath;\n    var circlePath;\n    var shapeOption;\n    location.x = location.x + marker.offset.x;\n    location.y = location.y - marker.offset.y;\n    var isBoxPlot = series.type === 'BoxAndWhisker';\n    var fill = marker.fill || (isBoxPlot ? point.interior || series.interior : '#ffffff');\n    var markerElement;\n    var parentElement = isBoxPlot ? findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index) : series.symbolElement;\n    border.color = borderColor || series.setPointColor(point, series.interior);\n    var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' + (index ? index : '');\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: point.isEmpty ? series.emptyPointSettings.fill || fill : fill,\n      border: {\n        color: series.type === 'BoxAndWhisker' ? !isNullOrUndefined(borderColor) && borderColor !== 'transparent' ? borderColor : getSaturationColor(fill, -0.6) : border.color,\n        width: border.width\n      },\n      height: marker.height,\n      width: marker.width,\n      shape: marker.shape\n    };\n    argsData.border = series.setBorderColor(point, {\n      width: argsData.border.width,\n      color: argsData.border.color\n    });\n\n    if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n      this.chart.trigger(pointRender, argsData);\n      point.color = argsData.fill;\n    }\n\n    point.color = argsData.fill;\n\n    if (!argsData.cancel) {\n      var y = void 0;\n\n      if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn' || series.type === 'SplineRangeArea') {\n        y = index ? point.low : point.high;\n      } else if (isBoxPlot) {\n        y = point.outliers[index];\n      } else {\n        y = point.y;\n      }\n\n      var markerFill = argsData.point.marker.fill || argsData.fill;\n      var markerBorder = void 0;\n\n      if (!isNullOrUndefined(argsData.point.marker.border)) {\n        markerBorder = {\n          color: argsData.point.marker.border.color || argsData.border.color,\n          width: argsData.point.marker.border.width || argsData.border.width\n        };\n      } else {\n        markerBorder = {\n          color: argsData.border.color,\n          width: argsData.border.width\n        };\n      }\n\n      var markerWidth = argsData.point.marker.width || argsData.width;\n      var markerHeight = argsData.point.marker.height || argsData.height;\n      var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n      var markerShape = argsData.point.marker.shape || argsData.shape;\n      var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n      shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\n\n      if (parentElement !== undefined && parentElement !== null || this.chart.enableCanvas) {\n        if (redraw && getElement(shapeOption.id)) {\n          markerElement = getElement(shapeOption.id);\n          circlePath = markerShape === 'Circle' ? 'c' : '';\n          previousLocation = {\n            x: +markerElement.getAttribute(circlePath + 'x'),\n            y: +markerElement.getAttribute(circlePath + 'y')\n          };\n          previousPath = markerElement.getAttribute('d');\n        }\n\n        markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n        appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n      }\n\n      point.marker = {\n        border: markerBorder,\n        fill: markerFill,\n        height: markerHeight,\n        visible: true,\n        shape: markerShape,\n        width: markerWidth,\n        imageUrl: imageURL\n      };\n    } else {\n      location = null;\n      point.marker = {\n        visible: false\n      };\n    }\n  };\n\n  Marker.prototype.createElement = function (series, redraw) {\n    var markerClipRect;\n    var marker = series.marker; // 8 for extend border value 5 for extend size value\n\n    var explodeValue = marker.border.width + 8 + 5;\n    var render = series.chart.svgRenderer;\n    var index = series.index === undefined ? series.category : series.index;\n    var options;\n    var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n\n    if (marker.visible) {\n      var markerHeight = (marker.height + explodeValue) / 2;\n      var markerWidth = (marker.width + explodeValue) / 2;\n\n      if (series.chart.chartAreaType === 'Cartesian') {\n        options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: -markerWidth,\n          y: -markerHeight,\n          width: series.clipRect.width + markerWidth * 2,\n          height: series.clipRect.height + markerHeight * 2\n        });\n        markerClipRect = appendClipElement(redraw, options, render);\n      } else {\n        options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n        markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n      }\n\n      options = {\n        'id': this.elementId + 'SymbolGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n      };\n      series.symbolElement = render.createGroup(options);\n      series.symbolElement.appendChild(markerClipRect);\n\n      if (this.chart.enableCanvas) {\n        var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n        element.appendChild(series.symbolElement);\n      }\n    }\n  };\n\n  Marker.prototype.getRangeLowPoint = function (region, series) {\n    var x = region.x;\n    var y = region.y;\n\n    if (series.chart.requireInvertedAxis) {\n      y += region.height / 2;\n      x += series.yAxis.isAxisInverse ? region.width : 0;\n    } else {\n      y += series.yAxis.isAxisInverse ? 0 : region.height;\n      x += region.width / 2;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * Animates the marker.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Marker.prototype.doMarkerAnimation = function (series) {\n    if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose' || series.chart.chartAreaType === 'PolarRadar' && series.drawType === 'Scatter')) {\n      var markerElements = series.symbolElement.childNodes;\n      var delay = series.animation.delay + series.animation.duration;\n      var duration = series.chart.animated ? series.chart.duration : 200;\n      var j = 1;\n      var incFactor = series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' ? 2 : 1;\n\n      for (var i = 0; i < series.points.length; i++) {\n        if (series.points[i].symbolLocations) {\n          if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n            continue;\n          }\n\n          markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n\n          if (incFactor === 2) {\n            var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n            markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n          }\n\n          j += incFactor;\n        }\n      }\n    }\n  };\n\n  return Marker;\n}(MarkerExplode);\n\nexport { Marker };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RectOption","appendChildElement","getElement","appendClipElement","findlElement","drawSymbol","markerAnimate","CircleOption","PathOption","Size","isNullOrUndefined","pointRender","MarkerExplode","getSaturationColor","Marker","_super","chart","_this","call","addEventListener","render","series","redraw","createElement","_loop_1","point","visible","symbolLocations","length","map","location","index","marker","shape","renderMarker","_i","_a","points","seriesIndex","undefined","category","border","color","width","borderColor","previousLocation","previousPath","circlePath","shapeOption","x","offset","y","isBoxPlot","type","fill","interior","markerElement","parentElement","seriesElement","childNodes","symbolElement","setPointColor","symbolId","elementId","argsData","cancel","name","isEmpty","emptyPointSettings","height","setBorderColor","isRectSeries","trigger","drawType","low","high","outliers","markerFill","markerBorder","markerWidth","markerHeight","markerOpacity","opacity","markerShape","imageURL","imageUrl","enableCanvas","id","getAttribute","toString","renderer","clipRect","duration","markerClipRect","explodeValue","svgRenderer","options","transform","chartAreaType","radius","Math","max","createGroup","appendChild","element","document","getElementById","getRangeLowPoint","region","requireInvertedAxis","yAxis","isAxisInverse","doMarkerAnimation","markerElements","delay","animation","animated","j","incFactor","i","lowPoint","regions"],"sources":["C:/Users/shahj/OneDrive/Documents/GitHub/Multifunctional-React-Dashboard/node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\n * Marker module used to render the marker for line type series.\n */\nvar Marker = /** @class */ (function (_super) {\n    __extends(Marker, _super);\n    /**\n     * Constructor for the marker module.\n     *\n     * @private\n     */\n    function Marker(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Render the marker for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.render = function (series) {\n        var _this = this;\n        var redraw = series.chart.redraw;\n        this.createElement(series, redraw);\n        var _loop_1 = function (point) {\n            if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n                point.symbolLocations.map(function (location, index) {\n                    if (series.marker.shape !== 'None') {\n                        _this.renderMarker(series, point, location, index, redraw);\n                    }\n                });\n            }\n        };\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            _loop_1(point);\n        }\n    };\n    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n        var seriesIndex = series.index === undefined ? series.category : series.index;\n        var marker = series.marker;\n        var border = {\n            color: marker.border.color,\n            width: marker.border.width\n        };\n        var borderColor = marker.border.color;\n        var previousLocation;\n        var previousPath;\n        var circlePath;\n        var shapeOption;\n        location.x = location.x + marker.offset.x;\n        location.y = location.y - marker.offset.y;\n        var isBoxPlot = series.type === 'BoxAndWhisker';\n        var fill = marker.fill || (isBoxPlot ? point.interior || series.interior : '#ffffff');\n        var markerElement;\n        var parentElement = isBoxPlot ?\n            findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)\n            : series.symbolElement;\n        border.color = borderColor || series.setPointColor(point, series.interior);\n        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' +\n            (index ? index : '');\n        var argsData = {\n            cancel: false, name: pointRender, series: series, point: point,\n            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,\n            border: {\n                color: series.type === 'BoxAndWhisker' ?\n                    (!isNullOrUndefined(borderColor) && borderColor !== 'transparent') ? borderColor :\n                        getSaturationColor(fill, -0.6)\n                    : border.color,\n                width: border.width\n            },\n            height: marker.height, width: marker.width, shape: marker.shape\n        };\n        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });\n        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n            this.chart.trigger(pointRender, argsData);\n            point.color = argsData.fill;\n        }\n        point.color = argsData.fill;\n        if (!argsData.cancel) {\n            var y = void 0;\n            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'\n                || series.type === 'SplineRangeArea') {\n                y = index ? point.low : point.high;\n            }\n            else if (isBoxPlot) {\n                y = point.outliers[index];\n            }\n            else {\n                y = point.y;\n            }\n            var markerFill = argsData.point.marker.fill || argsData.fill;\n            var markerBorder = void 0;\n            if (!isNullOrUndefined(argsData.point.marker.border)) {\n                markerBorder = {\n                    color: argsData.point.marker.border.color || argsData.border.color,\n                    width: argsData.point.marker.border.width || argsData.border.width\n                };\n            }\n            else {\n                markerBorder = { color: argsData.border.color, width: argsData.border.width };\n            }\n            var markerWidth = argsData.point.marker.width || argsData.width;\n            var markerHeight = argsData.point.marker.height || argsData.height;\n            var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n            var markerShape = argsData.point.marker.shape || argsData.shape;\n            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n            shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\n            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {\n                if (redraw && getElement(shapeOption.id)) {\n                    markerElement = getElement(shapeOption.id);\n                    circlePath = markerShape === 'Circle' ? 'c' : '';\n                    previousLocation = {\n                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')\n                    };\n                    previousPath = markerElement.getAttribute('d');\n                }\n                markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n                appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n            }\n            point.marker = {\n                border: markerBorder, fill: markerFill, height: markerHeight,\n                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL\n            };\n        }\n        else {\n            location = null;\n            point.marker = {\n                visible: false\n            };\n        }\n    };\n    Marker.prototype.createElement = function (series, redraw) {\n        var markerClipRect;\n        var marker = series.marker;\n        // 8 for extend border value 5 for extend size value\n        var explodeValue = marker.border.width + 8 + 5;\n        var render = series.chart.svgRenderer;\n        var index = series.index === undefined ? series.category : series.index;\n        var options;\n        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';\n        if (marker.visible) {\n            var markerHeight = (marker.height + explodeValue) / 2;\n            var markerWidth = (marker.width + explodeValue) / 2;\n            if (series.chart.chartAreaType === 'Cartesian') {\n                options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                    x: -markerWidth, y: -markerHeight,\n                    width: series.clipRect.width + markerWidth * 2,\n                    height: series.clipRect.height + markerHeight * 2\n                });\n                markerClipRect = appendClipElement(redraw, options, render);\n            }\n            else {\n                options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n                markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n            }\n            options = {\n                'id': this.elementId + 'SymbolGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n            };\n            series.symbolElement = render.createGroup(options);\n            series.symbolElement.appendChild(markerClipRect);\n            if (this.chart.enableCanvas) {\n                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n                element.appendChild(series.symbolElement);\n            }\n        }\n    };\n    Marker.prototype.getRangeLowPoint = function (region, series) {\n        var x = region.x;\n        var y = region.y;\n        if (series.chart.requireInvertedAxis) {\n            y += region.height / 2;\n            x += series.yAxis.isAxisInverse ? region.width : 0;\n        }\n        else {\n            y += series.yAxis.isAxisInverse ? 0 : region.height;\n            x += region.width / 2;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Animates the marker.\n     *\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.doMarkerAnimation = function (series) {\n        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||\n            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {\n            var markerElements = series.symbolElement.childNodes;\n            var delay = series.animation.delay + series.animation.duration;\n            var duration = series.chart.animated ? series.chart.duration : 200;\n            var j = 1;\n            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea') ? 2 : 1;\n            for (var i = 0; i < series.points.length; i++) {\n                if (series.points[i].symbolLocations) {\n                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n                        continue;\n                    }\n                    markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n                    if (incFactor === 2) {\n                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n                        markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n                    }\n                    j += incFactor;\n                }\n            }\n        }\n    };\n    return Marker;\n}(MarkerExplode));\nexport { Marker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}