{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the data label module.\n   *\n   * @private\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    this.chart = chart;\n  }\n\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform = '';\n    var clipPath = '';\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n\n    if (series.chart.chartAreaType === 'Cartesian') {\n      transform = 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')';\n      clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n    }\n\n    if (marker.dataLabel.visible) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': clipPath\n      });\n    }\n\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'transparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n  };\n  /**\n   * Render the data label for series.\n   *\n   * @returns {void}\n   */\n\n\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    // initialize the private variable\n    this.initPrivateVariables(series, series.marker);\n    var rect;\n    var labelLocation = {\n      x: 0,\n      y: 0\n    };\n    var rgbValue;\n    var contrast;\n    var argsData;\n    var border;\n    var textSize;\n    var angle;\n    var degree;\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isAxisInverse;\n    var redraw = chart.redraw;\n    var isDataLabelOverlap = false;\n    var coordinatesAfterRotation = [];\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    });\n    var visiblePoints = getVisiblePoints(series);\n    var point;\n    var rectCenterX;\n    var rectCenterY; // Data label point iteration started\n\n    for (var i = 0; i < visiblePoints.length; i++) {\n      point = visiblePoints[i];\n\n      if (!dataLabel.showZero && (point.y !== 0 || point.y === 0 && series.emptyPointSettings.mode === 'Zero')) {\n        return null;\n      }\n\n      this.margin = dataLabel.margin;\n      var labelText = [];\n      var labelLength = void 0;\n      var xPos = void 0;\n      var yPos = void 0;\n      var xValue = void 0;\n      var yValue = void 0;\n      var isRender = true;\n      var clip = series.clipRect;\n      var shapeRect = void 0;\n      isDataLabelOverlap = false;\n      angle = degree = dataLabel.angle;\n      border = {\n        width: dataLabel.border.width,\n        color: dataLabel.border.color\n      };\n      var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n\n      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n        labelText = getLabelText(point, series, chart);\n        labelLength = labelText.length;\n\n        for (var i_1 = 0; i_1 < labelLength; i_1++) {\n          argsData = {\n            cancel: false,\n            name: textRender,\n            series: series,\n            point: point,\n            text: labelText[i_1],\n            border: border,\n            color: dataLabel.fill,\n            template: dataLabel.template,\n            font: argsFont,\n            location: labelLocation,\n            textSize: measureText(labelText[i_1], dataLabel.font)\n          };\n          chart.trigger(textRender, argsData);\n\n          if (!argsData.cancel) {\n            this.fontBackground = argsData.color;\n            this.isDataLabelShape(argsData);\n            this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : this.markerHeight;\n\n            if (argsData.template !== null) {\n              this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n            } else {\n              if (this.chart.useGroupingSeparator && Number(argsData.text)) {\n                argsData.text = this.chart.intl.formatNumber(+argsData.text, {\n                  useGrouping: this.chart.useGroupingSeparator\n                });\n              }\n\n              textSize = measureText(argsData.text, dataLabel.font);\n              rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1); // To check whether the polar radar chart datalabel intersects the axis label or not\n\n              if (chart.chartAreaType === 'PolarRadar') {\n                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                  var rectRegion = _a[_i];\n\n                  if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                    isRender = false;\n                    break;\n                  }\n                }\n              }\n\n              var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height); //let notOverlapping: boolean;\n\n              if (dataLabel.enableRotation) {\n                var rectCoordinates = this.getRectanglePoints(rect);\n                rectCenterX = rect.x + rect.width / 2;\n                rectCenterY = rect.y + rect.height / 2;\n                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n\n                if (!isDataLabelOverlap) {\n                  this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                  var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n\n                  for (var index = currentPointIndex; index >= 0; index--) {\n                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                      isDataLabelOverlap = true;\n                      this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                      break;\n                    }\n                  }\n                }\n              } else {\n                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n              }\n\n              if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                chart.dataLabelCollections.push(actualRect);\n\n                if (this.isShape) {\n                  shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n\n                  if (series.shapeElement) {\n                    series.shapeElement.appendChild(shapeRect);\n                  }\n                } // Checking the font color\n\n\n                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;\n                yPos = rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;\n                labelLocation = {\n                  x: 0,\n                  y: 0\n                };\n\n                if (angle !== 0 && dataLabel.enableRotation) {\n                  // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                  xValue = rectCenterX; //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                  // (dataLabel.margin.bottom) / 2;\n\n                  yValue = rectCenterY;\n                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n                } else {\n                  degree = 0;\n                  xValue = rect.x;\n                  yValue = rect.y;\n                }\n\n                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + xValue + ',' + yValue + ')', 'auto', degree), argsData.font, argsData.font.color || (contrast >= 128 || series.type === 'Hilo' ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (element.childElementCount) {\n      if (!chart.enableCanvas) {\n        appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, // eslint-disable-next-line @typescript-eslint/indent\n        false, 'x', 'y', null, '', false, false, null, chart.duration);\n      } else {\n        getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n      }\n    }\n  };\n  /**\n   * Get rect coordinates\n   */\n\n\n  DataLabel.prototype.getRectanglePoints = function (rect) {\n    var loc1 = new ChartLocation(rect.x, rect.y);\n    var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [loc1, loc2, loc3, loc4];\n  };\n\n  DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n    for (var index = 0; index < rectCoordinates.length; index++) {\n      if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Render the data label template.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n    this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n  };\n\n  DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n    var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    var clipWidth = 0;\n    var clipHeight = 0;\n    var isOverlap = false;\n\n    if (isReactCallback) {\n      isOverlap = elementRect.width === 0 || elementRect.height === 0; // To check the data label already overlap before react callback call\n      // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n      //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n      // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n    }\n\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight + 'px';\n    var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    childElement.style.color = dataLabel.font.color || (Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000) >= 128 ? 'black' : 'white');\n\n    if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('Stacking') > -1 || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n\n      if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n        this.doDataLabelAnimation(series, childElement);\n      } else if (this.chart.enableCanvas) {\n        parentElement.appendChild(childElement);\n      }\n    }\n  };\n\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect; // calculating alignment\n\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.y = dataLabel.position === 'Auto' ? location.y : this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false); // calculating position\n\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n\n    var rect = calculateRect(location, textSize, this.margin); // Checking the condition whether data Label has been exist the clip rect\n\n    if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? padding : rect.x;\n      rect.y = rect.y < 0 && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n\n    return rect;\n  }; // Calculation label location for polar column draw types\n\n\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n    var padding = 5;\n    var columnRadius;\n    var chartWidth = this.chart.availableSize.width;\n    var alignmentSign = alignment === 'Center' ? 0 : alignment === 'Far' ? 1 : -1;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n\n      if (series.drawType === 'StackingColumn') {\n        columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;\n      }\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = 2 * padding;\n      columnRadius += series.drawType === 'StackingColumn' ? point.regionData.innerRadius + this.markerHeight : 0;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n\n    columnRadius += alignmentValue * alignmentSign;\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle); // To change x location based on text anchor for column and stackingcolumn chart\n\n    if (series.drawType === 'StackingColumn') {\n      location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;\n    } else if (series.drawType === 'Column') {\n      location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;\n    }\n\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\n   * Get the label location\n   */\n\n\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    } //Aligning the label at the beginning of the tick, when tick size is less than text size\n\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = !this.inverted ? textSize.height : textSize.width;\n    var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 && Math.abs(rect.height - textSize.height) < padding ? 0 : padding);\n\n    if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height + extraSpace + margin.top : labelLocation + rect.height - extraSpace - margin.bottom : isMinus ? labelLocation + rect.width - extraSpace - margin.left : labelLocation - rect.width + extraSpace + margin.right;\n        break;\n\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n\n      default:\n        extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n        break;\n    }\n\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    var seriesLength = series.chart.series.length;\n\n    if (position === 'Outer' && series.type.indexOf('Stacking') > -1 && seriesLength - 1 > series.index) {\n      var nextSeries = void 0;\n      var nextSeriesPoint = void 0;\n\n      for (var i = series.index + 1; i < seriesLength; i++) {\n        nextSeries = series.chart.series[i];\n        nextSeriesPoint = nextSeries.points[point.index];\n\n        if (nextSeries.type.indexOf('Stacking') > -1 && nextSeries.type.indexOf('100') === -1) {\n          this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;\n          break;\n        }\n      }\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n\n    while (isOverLap && position < finalPosition) {\n      var actualPosition = this.getPosition(position);\n\n      if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n        actualPosition = 'Top';\n        position++;\n      }\n\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n\n      if (!this.inverted) {\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n\n      position++;\n    }\n\n    return location;\n  }; // alignment calculation assigned here\n\n\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n      // eslint-disable-next-line no-self-assign\n\n      case 'Center':\n        labelLocation = labelLocation;\n        break;\n    }\n\n    return labelLocation;\n  }; //calculation for top and outer position of datalabel for rect series\n\n\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n    var margin = this.margin;\n    var top;\n\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'SplineRangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n\n        break;\n\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer') {\n          location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.left + this.markerHeight;\n        } else {\n          location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n        }\n\n        break;\n    }\n\n    return location;\n  };\n  /**\n   * Updates the label location\n   */\n\n\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n\n    return yLocation;\n  };\n  /**\n   * Animates the data label.\n   *\n   * @param  {Series} series - Data label of the series gets animated.\n   * @returns {void}\n   */\n\n\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, duration, series, null, location, true);\n\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, duration, series, null, location, true);\n        }\n      }\n    }\n  };\n\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\n   * Get module name.\n   */\n\n\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the dataLabel for series.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.destroy = function () {// Destroy method performed here\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":{"version":3,"names":["ChartLocation","RectOption","isCollide","isOverlap","markerAnimate","appendChildElement","getVisiblePoints","getLabelText","convertHexToColor","calculateRect","textElement","colorNameToHex","measureText","TextOption","Rect","textRender","createTemplate","getFontStyle","getElement","measureElementRect","templateAnimate","withIn","withInBounds","createElement","getValue","extend","getPoint","getRotatedRectangleCoordinates","isRotatedRectIntersect","DataLabel","chart","errorHeight","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","shapeElement","createGroup","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","rect","labelLocation","rgbValue","contrast","argsData","border","textSize","angle","degree","inverted","requireInvertedAxis","yAxisInversed","yAxis","isAxisInverse","redraw","isDataLabelOverlap","coordinatesAfterRotation","templateId","visiblePoints","point","rectCenterX","rectCenterY","i","length","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","isRender","clip","shapeRect","width","color","argsFont","font","symbolLocations","regions","i_1","cancel","name","text","fill","template","location","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","useGroupingSeparator","Number","intl","formatNumber","useGrouping","calculateTextPosition","_i","_a","chartAxisLayoutPanel","visibleAxisLabelRect","rectRegion","actualRect","enableRotation","rectCoordinates","getRectanglePoints","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","dataLabelCollections","labelIntersectAction","isShape","drawRectangle","opacity","rx","ry","Int32Array","appendChild","Math","round","r","g","b","left","top","duration","enableCanvas","childElementCount","loc1","loc2","loc3","loc4","initialClipRect","parentElement","data","labelIndex","right","bottom","childElement","styles","calculateTemplateLabelSize","isReactCallback","elementRect","clipWidth","clipHeight","style","vAxis","xAxis","hAxis","seriesType","visibleRange","indexOf","stackedValues","endValues","parseFloat","animation","enable","animateSeries","doDataLabelAnimation","labelRegion","getLabelLocation","padding","locationX","alignmentValue","borderWidth","calculateAlignment","alignment","calculatePathPosition","calculateRectPosition","calculatePolarRectPosition","locationY","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","abs","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","points","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","nextPoint","previousPoint","yLocation","isBottom","positionIndex","slope","intersectY","shapeElements","childNodes","textNode","delay","animated","tempElement","visibility","getAttribute","getModuleName","destroy"],"sources":["C:/Users/shahj/OneDrive/Documents/GitHub/Admin-Dashboard/frontend/node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js"],"sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     *\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n    };\n    /**\n     * Render the data label for series.\n     *\n     * @returns {void}\n     */\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        var rect;\n        var labelLocation = { x: 0, y: 0 };\n        var rgbValue;\n        var contrast;\n        var argsData;\n        var border;\n        var textSize;\n        var angle;\n        var degree;\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isAxisInverse;\n        var redraw = chart.redraw;\n        var isDataLabelOverlap = false;\n        var coordinatesAfterRotation = [];\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = createElement('div', {\n            id: templateId\n        });\n        var visiblePoints = getVisiblePoints(series);\n        var point;\n        var rectCenterX;\n        var rectCenterY;\n        // Data label point iteration started\n        for (var i = 0; i < visiblePoints.length; i++) {\n            point = visiblePoints[i];\n            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n                return null;\n            }\n            this.margin = dataLabel.margin;\n            var labelText = [];\n            var labelLength = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var xValue = void 0;\n            var yValue = void 0;\n            var isRender = true;\n            var clip = series.clipRect;\n            var shapeRect = void 0;\n            isDataLabelOverlap = false;\n            angle = degree = dataLabel.angle;\n            border = { width: dataLabel.border.width, color: dataLabel.border.color };\n            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n            if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n                (series.type === 'BoxAndWhisker' && point.regions.length)) {\n                labelText = getLabelText(point, series, chart);\n                labelLength = labelText.length;\n                for (var i_1 = 0; i_1 < labelLength; i_1++) {\n                    argsData = {\n                        cancel: false, name: textRender, series: series,\n                        point: point, text: labelText[i_1], border: border,\n                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                        textSize: measureText(labelText[i_1], dataLabel.font)\n                    };\n                    chart.trigger(textRender, argsData);\n                    if (!argsData.cancel) {\n                        this.fontBackground = argsData.color;\n                        this.isDataLabelShape(argsData);\n                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                        if (argsData.template !== null) {\n                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n                        }\n                        else {\n                            if (this.chart.useGroupingSeparator && Number(argsData.text)) {\n                                argsData.text = this.chart.intl.formatNumber(+argsData.text, {\n                                    useGrouping: this.chart.useGroupingSeparator\n                                });\n                            }\n                            textSize = measureText(argsData.text, dataLabel.font);\n                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\n                            // To check whether the polar radar chart datalabel intersects the axis label or not\n                            if (chart.chartAreaType === 'PolarRadar') {\n                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                                    var rectRegion = _a[_i];\n                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                                        isRender = false;\n                                        break;\n                                    }\n                                }\n                            }\n                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                            //let notOverlapping: boolean;\n                            if (dataLabel.enableRotation) {\n                                var rectCoordinates = this.getRectanglePoints(rect);\n                                rectCenterX = rect.x + (rect.width / 2);\n                                rectCenterY = (rect.y + (rect.height / 2));\n                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n                                if (!isDataLabelOverlap) {\n                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                    for (var index = currentPointIndex; index >= 0; index--) {\n                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                            this.chart.rotatedDataLabelCollections[index - 1] &&\n                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                            isDataLabelOverlap = true;\n                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n                            }\n                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                                chart.dataLabelCollections.push(actualRect);\n                                if (this.isShape) {\n                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n                                    if (series.shapeElement) {\n                                        series.shapeElement.appendChild(shapeRect);\n                                    }\n                                }\n                                // Checking the font color\n                                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                                labelLocation = { x: 0, y: 0 };\n                                if (angle !== 0 && dataLabel.enableRotation) {\n                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                    xValue = rectCenterX;\n                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                    // (dataLabel.margin.bottom) / 2;\n                                    yValue = rectCenterY;\n                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                                }\n                                else {\n                                    degree = 0;\n                                    xValue = rect.x;\n                                    yValue = rect.y;\n                                }\n                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||\n                                    ((contrast >= 128 || series.type === 'Hilo') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, \n                // eslint-disable-next-line @typescript-eslint/indent\n                false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    /**\n     * Get rect coordinates\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new ChartLocation(rect.x, rect.y);\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Render the data label template.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = createTemplate(createElement('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        var isOverlap = false;\n        if (isReactCallback) {\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        childElement.style.color = dataLabel.font.color ||\n            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');\n        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.y = (dataLabel.position === 'Auto') ? location.y :\n                this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        var rect = calculateRect(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? padding : rect.x;\n            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Get the label location\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = !this.inverted ? textSize.height : textSize.width;\n        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\n            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :\n                        (labelLocation + rect.height - extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :\n                        (labelLocation - rect.width + extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n            }\n            else {\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n            // eslint-disable-next-line no-self-assign\n            case 'Center':\n                labelLocation = labelLocation;\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'SplineRangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {\n                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :\n                        location + extraSpace + margin.left + this.markerHeight;\n                }\n                else {\n                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :\n                        location - extraSpace - margin.right - this.markerHeight;\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the label location\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Animates the data label.\n     *\n     * @param  {Series} series - Data label of the series gets animated.\n     * @returns {void}\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                templateAnimate(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                markerAnimate(tempElement, delay, duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    markerAnimate(tempElement, delay, duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\nexport { DataLabel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}